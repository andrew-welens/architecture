# Архитектура

## API Service

Зона ответственности API Service - запросы к серверу через Angular HTTP Client и
рантайм валидация ответов. В случае неверного формата ответа, нужно вывести ошибку
через сервис обработки ошибок и вывести полученные данные в лог через сервис
логирования. API Service реализует контракт с сервером, описанный в Swagger
Единственной причиной его изменения может быть изменение контракта.
Потенциально, код API Service может генерироваться автоматически на основе
спецификации АРI.

## Toolkit Component

Toolkit component - абстрактный переиспользуемый компонент, не имеющий бизнес-
специфичной логики. Может быть как компонентом, директивой или пайпом Angular, так
и обычным классом или функцией. Не должен иметь зависимостей от других слоев
приложения, может зависеть от внешних библиотек.

## Infrastructure Service

Инфраструктурный сервис реализует функциональность приложения, не относящуюся к
бизнес-логике. Примером может быть сервис обработки ошибок или сервис логирования.
Так же может быть интерсептором, гвардом или другой вспомогательной сущностью
приложения.

## Data

Слой для получения, отправки и хранения данных. Позволяет бизнес-логике сохранять
независимость от деталей реализации транспорта. Зависит от слоя Соге через
интерфейсы, которые должны быть реализованы. Это инвертированная зависимость,
поток исполнения будет направлен от слоя Соге к Data, тогда как направление
зависимости - противоположное. Контракт с сервером является неявной зависимостью
этого слоя и его изменения могут быть причиной изменения этого слоя. Такие изменения
не должны становиться причиной изменений в слое Соге.

## Infrastructure

Слой для инфраструктуры приложения, которая не является бизнес-логикой.
Предназначен для такой функциональности, как логированиеm, обработка  и вывод
ошибок. Зависит от слоя Соге через интерфейсы, которые должны быть реализованы.
Это инвертированная зависимость, поток исполнения будет направлен от слоя Соге к
Infrastructure, тогда как направление зависимости - противоположное.

## Toolkit

Слой для переиспользуемых абстрактных компонентов и вспомогательных функций. В
данном слое не должно быть бизнес-специфичного кода, любой код из этого слоя может
быть переиспользован в совершенно другом приложении. Может иметь зависимости от
внешних библиотек. При использовании внешних библиотек в других слоях (например, UI
или Data), рекомендуется размещать обертки для них в данном слое. Компоненты этого,
слоя должны быть максимально независимыми друг от друга.

## Container

Контейнер играет роль адаптера между UI компонентом и контроллером. Реализуется с
помощью компонента Angular. Подключает контроллер через DI, подписывается на потоки
контроллера через async pipe, передает данные и нужные методы контроллера в UI
компонент через @Input и @Output. Не содержит стилей и собственной HTML разметки,
кроме подключаемого компонента.

## UI Component

UI компонент реализует бизнес-специфичные аспекты пользовательского интерфейса.
Получает данные через @Input, отдает наружу пользовательские действия через @Output.
Может зависеть от Toolkit компонентов. Имеет собственную HTML разметку и стили.
Может быть декомпозирован на несколько UI компонентов в рамках одного модуля
Angular. В отдельных случаях может использовать контейнеры, сервисы и директивы из
других модулей UI слоя. При этом нужно не допускать появления циклических
зависимостей. Переиспользуемые модули из UI слоя должны быть явно обозначены как
shared и, в свою очередь, не иметь зависимостей из UI слоя.

## Page

Компонент Page служит для работы с роутингом. Его зона ответственности - отобразить
нужные контейнеры в нужном Layout. Так же компонент Page ответственен за
отображение заголовков страниц(не актуально для angular 14, в роутинг добавили параметр 'title'). Не содержит стилей и собственной HTML разметки,
кроме Layout и контейнеров.

## Layout

Компонент Layout служит для компоновки глобальных UI компонентов вроде шапки и
навигационной панели вместе с локальными компонентами, специфичными для данной
страницы. Содержит стили, получает локальные компоненты через content.

## Gateway

Компонент Gateway представляет собой адаптер между контроллером и АРI сервисом.
Он реализует специальный интерфейс из Соге слоя и вызывает нужные методы АРI
сервиса. Может выполнять преобразование данных из ответа АРI сервиса к модели,
определенной в слое Соге, если такое преобразование необходимо.

## Архитектурные слои

Предлагается выделить следующие слои:

![Frame 1](https://user-images.githubusercontent.com/48022793/175523966-049a9564-0f7a-4163-abe8-5c607e538672.jpg)


Соге

Слой для бизнес-логики приложения. Абстрагирован от загрузки данных и
пользовательского интерфейса. Не должен иметь внешних зависимостей, кроме DI-
контейнера, RxJS. От этого слоя зависят почти все
остальные, поэтому изменения должны быть вноситься только при изменении бизнес-
требований, а внутренняя реализация компонентов этого слоя должна соответствовать
принципу открытости/закрытости, т.е. быть открытыми для расширения и закрытыми
для изменения.

UI

Слой для бизнес-специфичных компонентов интерфейса. Каждый компонент в этом слое
реализует определенную бизнес-функцию, большинство компонентов используются не
более одного раза. Компоненты в этом слое зависят от слоя Соге. UI слой чаще всего
подвергается изменениям, поэтому компоненты из других слоёв не должны от него
зависеть.

## Архитектурные компоненты

Слои реализуются различными компонентами:

![Frame 2](https://user-images.githubusercontent.com/48022793/175523992-e596b970-05bd-4413-937e-0b4786a9410f.jpg)


Model

Модель описывает структуру данных из предметной области. Предлагается
реализовывать модели с помощью типов TypeScript. Модель не должна иметь внешних
зависимостей. Единственная причина изменения в модели - изменения бизнес-
требований. При внесении изменений стоит руководствоваться принципом открытости/
закрытости, не изменять и не удалять существующие поля, т.к. это может привести к
необходимости вносить изменения по всему приложению.

Controller

Контроллер предоставляет непосредственный доступ с бизнес-логике приложения через
свои методы и потоки RxJS. Данные наружу поставляются через потоки, а действия
производятся через методы контроллера. Контроллер реализует заранее определенный
интерфейс, следует принципу открытости/закрытости. Внутренняя реализация
контроллера может быть различной и состоять из нескольких компонентов. Вне
зависимости от реализации, контроллер должен реализовывать описанный интерфейс,
на который полагаются внешние пользователи.
